## Inspiration
UnityFund is inspired by the need for a secure, private channel for community giving. We address donor anonymity by separating the confidential User identity from the public Wallet ID used in all transfers. Technical trust is achieved through core Object-Oriented Programming (OOP), which enforces Account Segregation by assigning every user a unique, isolated Wallet object. This architectural integrity establishes UnityFund as a direct, private tool for peer-to-peer and charitable finance, designed to be a complementary tool alongside traditional banking services.
## What it does
UnityFund provides a secure, fully segregated platform for community-focused finance. Users can securely register and log in to a clean dashboard to manage their unique funds. The core features allow users to deposit funds into their private wallet and execute anonymous transfers to any recipient using only their unique Wallet ID. A built-in "Copy ID" function streamlines the process of sharing the receiving address, making private, peer-to-peer giving simple and immediate. The system guarantees that funds are completely isolated between users, protecting the integrity of every individual wallet.
## How we built it
The application is built entirely in Python using the standard Tkinter library for the desktop-based graphical user interface. The foundation of the platform's security relies on Object-Oriented Programming (OOP) principles, where every user is assigned a unique, isolated Wallet object, guaranteeing Account Segregation. We utilized Python's built-in uuid library to generate anonymous, unguessable Wallet IDs and the hashlib library (SHA-256) for secure password handling. The entire system is managed via an In-Memory Community Ledger, ensuring fast, real-time transaction processing.
## Challenges we ran into
Two major challenges we ran into were actually coding the application and accidental wallet linking. Since my team and I are complete beginners, we all had basic knowledge of Python, so developing and making our idea into code was challenging to start with and to build. We used our references and past projects to progress into our coding. Another major challenge we ran into was the accidental linking of the user wallets. Class User was initializing the wallet incorrectly, causing all User instances to reference the same Wallet object's memory location. What we did to fix it was that we ensured that the "User" constructor used "self.wallet = Wallet(initial_balance=...)." This made it so that it creates a new and unique Wallet instance for every user, which obviously leads to account segregation. Fixing the linked accounts issue.
## Accomplishments that we're proud of
I'm proud of two things: how the front-end turned out, and also learning how to analyze and solve the linking wallets issue. I really liked learning generally how to construct the front end of an application using Python and tkinter, and how it's formatted. Seeing the GUI come to life and being interactable and functional motivated me to keep on learning. Even though I spent hours trying to figure out how to fix the wallet linking problem, it was fun to analyze and use my resources to figure out what was wrong. In the process, I also fixed some formatting issues and such, small tweaks here and there to make the GUI more user-friendly. 
## What we learned
I learned most of what I know now here at this Hackathon. Before this Hackathon, I really only knew basic logic and syntax of Python, but now I understand more about Object-oriented Programming, Hashing for security, Design, user interface with tkinter, using libraries such as hashlib and uuid, and the architecture of an app and its integrity and security.
## What's next for UnityFund
I hope to continue this project, but with React. I have built a design using Figma, and I am really curious to see how I can use React to integrate it. I will have to learn HTML, CSS, React, and other API's. I really think I can develop my skills with this little project. I want to implement transaction history, community pools, and data persistence, and I want to add an extra security feature called salting. Those are ideas I have right now, but as I progress, more ideas will start to flow in.
